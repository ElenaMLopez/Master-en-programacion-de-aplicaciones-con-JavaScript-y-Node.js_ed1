![shieldsIO](https://img.shields.io/github/issues/Fictizia/Master-en-programacion-de-aplicaciones-con-JavaScript-y-Node.js_ed1.svg)
![shieldsIO](https://img.shields.io/github/forks/Fictizia/Master-en-programacion-de-aplicaciones-con-JavaScript-y-Node.js_ed1.svg)
![shieldsIO](https://img.shields.io/github/stars/Fictizia/Master-en-programacion-de-aplicaciones-con-JavaScript-y-Node.js_ed1.svg)

![WideImg](http://fictizia.com/img/github/Fictizia-plan-estudios-github.jpg)

# Master en Programación de Aplicaciones con JavaScript y Node.js
### JS, Node.js, Frontend, Express, Patrones, IoT, HTML5_APIs, Asincronía, Websockets, ECMA6, ECMA7

## Clase 108

### Python

- Creado por [Guido van Rossum](https://www.wikiwand.com/es/Guido_van_Rossum) a principios de los años 90
- Extensiones: .py, .pyc, .pyd, .pyo, .pyw
- Sintaxis simple, clara y sencilla;
- Lenguaje similar a Perl
- Nombre está inspirado en el grupo de cómicos ingleses “Monty Python”
- Lenguaje (semi-)interpretado o de script (neceistamos un interprete)
    - El código fuente se traduce a un pseudo código máquina intermedio llamado bytecode la primera vez que se ejecuta, generando archivos .pyc o .pyo (bytecode optimizado), que son los que se ejecutarán en sucesivas ocasiones.
- Tipado dinámico
    - Nos se declara el tipo de variable 
- Fuertemente tipado
    - Conversión explícita entre tipos 
- Multiplataforma
- Programación soportada
    - POO
    - Imperativa
    - Funcional
    - Orientada a aspectos
- No recomendado para bajo nivel o aplicacioens de rendimeitno crítico
- Lo usan... Google, NASA, Industrias Light & Magic y todas las distribuciones Linux

### Python: Implementaciones de Python

- **CPython**
    - Más extendida
    - Instalada por defecto en MAC y Linux
    - Escrita en C
- **Jython**
    - Permite usar las librerías de Java
    - Escrita en Java
- **IronPython**
    - Permite usar las librerías de .NET
    - C# (.NET)
- **PyPy**
    - Implementación de Python en Python

### Python: Versión 2.x o 3.x

- [Python 2.7 will retire in... 2020](https://pythonclock.org/)
- [Las perlas de Python 3 por Facundo Batista - PyCon](https://www.youtube.com/watch?v=cVvRKthOvYs)

### Verificación e instalación de Python

- Escribe *python* en la terminal 
```
    Python 2.7.6 (default, Jun 22 2015, 17:58:13) 
    [GCC 4.8.2] on linux2
    Type "help", "copyright", "credits" or "license" for more information.
    >>> 
```

- Escribe *python3* en la terminal 
```
    Python 3.4.3 (default, Oct 14 2015, 20:28:29) 
    [GCC 4.8.4] on linux
    Type "help", "copyright", "credits" or "license" for more information.
    >>>
```

- Salir del interprete pulsando *Control + D* o escribiendo *exit()*
- [Instalar Python](https://www.python.org/downloads/)


### Python: Filosofía Python
**Tim Peters, El Zen de Python**
- Bello es mejor que feo.
- Explícito es mejor que implícito.
- Simple es mejor que complejo.
- Complejo es mejor que complicado.
- Plano es mejor que anidado.
- Disperso es mejor que denso.
- La legibilidad cuenta.
- Los casos especiales no son tan especiales como para quebrantar las reglas.
- Lo práctico gana a lo puro.
- Los errores nunca deberían dejarse pasar silenciosamente.
- A menos que hayan sido silenciados explícitamente.
- Frente a la ambigüedad, rechaza la tentación de adivinar.
- Debería haber una -y preferiblemente sólo una- manera obvia de hacerlo.
- Aunque esa manera puede no ser obvia al principio a menos que usted sea holandés.
- Ahora es mejor que nunca.
- Aunque nunca es a menudo mejor que ya mismo.
- Si la implementación es difícil de explicar, es una mala idea.
- Si la implementación es fácil de explicar, puede que sea una buena idea.
- Los espacios de nombres (namespaces) son una gran idea ¡Hagamos más de esas cosas!

### [Python: Librerías
- [Python Standard](https://docs.python.org/3/library/)
- [Pypi: Librerías de terceros](https://pypi.python.org/pypi)


### Python: Ejecutando código

Creamos el archivo *hola.py* y preparamos nuestro *Hola Mundo*
```
    #!/usr/bin/env python3
    print("Hola", "Mundo")
```



### Python: Guía de estilos para Python

- **[PEP8](https://www.python.org/dev/peps/pep-0008/)**
- [Google Python Style Guide](https://google.github.io/styleguide/pyguide.html)
- [Hitchhiker's Guide to Python](http://docs.python-guide.org/en/latest/writing/style/)
- [DJango - Coding style](https://docs.djangoproject.com/en/dev/internals/contributing/writing-code/coding-style/)
- [Code Like a Pythonista: Idiomatic Python](http://python.net/~goodger/projects/pycon/2007/idiomatic/handout.html)
- [The Chromium Projects - Python Style Guidelines](https://www.chromium.org/chromium-os/python-style-guidelines)



### Python: Usando el intérprete de Python

**Lanzando el interprete**
- Escribe `python` en la terminal 
```
    Python 2.7.6 (default, Jun 22 2015, 17:58:13) 
    [GCC 4.8.2] on linux2
    Type "help", "copyright", "credits" or "license" for more information.
    >>> 
```

- Escribe `python3` en la terminal 
```
    Python 3.4.3 (default, Oct 14 2015, 20:28:29) 
    [GCC 4.8.4] on linux
    Type "help", "copyright", "credits" or "license" for more information.
    >>>
```

**Salir del interprete**
- comando
```
exit()
```
- teclado
	- Control+D (Unix)
	- Control+Z (Windows)

**Pasaje de argumentos**
- Argumentos adiccionales que se introducen junto al script.
- Se pueden consultar desde la variable *argv* dek módulo *sys*

### Usando el intérprete de Python (Codificación)

**Codificación del código fuente**
- UTF-8 por defecto
- ASCII para la biblioteca estándar, relevante para la portabilidad
- Especificando otras codificaciones
	```python
	# -*- coding: cp-1252 -*-
	```

### Python: Usando el intérprete de Python (Cadenas de caracteres)

**Indentación**
- No se usan llaves ({}) para delimitar bloques de código
- No se usa punto y coma (;) para delimitar sentencias
- El codigo se estrcutura y divide según los espacios en blanco a la izquierda
- Existe una jerarquía muy clara para mantener una indentación correcta en Python

**Comillas**
- Podemos usar varios tipos de comillas
- Podemos entremezclar las comillas.
- Ejemplos:
```python
print("doesn't")
print('doesn\'t')
```

**Triples comillas**
```python
print("""\
Uso: algo [OPTIONS]
 -h Muestra el mensaje de uso
 -H nombrehost Nombre del host al cual conectarse
""")
```

**Cadenas Crudas**
- Evitamos que el caracter *\* se interprete como un caracter especial
```python
print('C:\Ruta\nuevaCarpeta') 
print(r'C:\Ruta\nuevaCarpeta') 
```

**Concatenado, repetición...**
- Concatenación directa
	- Solo funciona entre cadenas 
```python
print("ho""la!")
```

- Concatenación con Operador
```python
print("ho" + "la!")
```

- Repetición
```python
print(3 * "ho""la!" )
print("h"+ (5 * "o") + "la!" )
```

### Python: Programas ejecutables de Python

**Sistemas UNIX**
- Shebang
```python
#! /usr/bin/env python3
```
- Permisos a nuestro script
```
sudo chmod +x myscript.py
```

**Windows**
- Los archivos de extensión *.py* y *.piw* se ejecutan automaticamente con *python.exe* como un ejecutable más


### Python: Interacción Básica con el Usuario
- Pedir información
```python
dato_usuario = input("Mide algo: ")
```
- Mostrar información
```python
print("Hola, Hola...")
```

### Python: Instalar Python 3.5
```
sudo add-apt-repository ppa:fkrull/deadsnakes
sudo apt-get update
sudo apt-get install python3.5
```

### Python: Caracteres especiales:

- `\t` *Tabulador*
- `\v` *Tabulador Vertical*
- `\'` *Comillas Simples*
- `\"` *Comillas Dobles*
- `\\` *\*
- `\n` *Salto de línea*
- Otros muchos...

```python
    def caracteresDemo ():
        print("Hasta aquí... todo correcto. Ahora vamos a \"tabular\":\tves? Ya estamos más lejos.\n\'Otra linea ;-)\'")
    
    caracteresDemo ()
```



### Python: Comentarios

- Una línea
```
# Comentario en una línea
```
- Multiples Líneas
```python
"""
Una Línea....
Otra linea...
Etc...
"""
```
- [PyDoc](https://www.wikiwand.com/en/Pydoc)
- [How do I create documentation with Pydoc?](http://stackoverflow.com/questions/13040646/how-do-i-create-documentation-with-pydoc)


### Python: Variables

**Características**
- Las variables se definen "al vuelo"
- Las variables no poseen un tipo intrinsico, por ello puede cambiar de estados y tipo de datos durante la ejecucción
- Python itnernamente utiliza las referencias para encontrar la vinculación correspondiente en la memoria.
- Al alterar el valor de una variable, se dispara un proceso de "revinculación".
- El recolector de basura (garbage collector) funciona de manera automática.
- Las variables se pueden definir a nivel de script (global) o local en el interior de las funciones.
- No es posible duplicar nombres de variables (internas/globales) por lo que se sobreescriben valores.
- En Python es común:
    - Utilizar la primera letra en Mayusculas en el caso de identificar clases
    - Utilizar guión bajo (``_variable``) para identificar elementos privados
    - Utilizar doble guión bajo (``__variable``) para remarcar elementos privados
    - Utilizar doble guión bajo al principio y al final (``__variable__``) para referirnos a elementos propios del lenguaje

**Palabras reservadas**

- Verificar:
```
    dir(__builtins__)
```
- Resultados:
```
    ['ArithmeticError', 'AssertionError', 'AttributeError', 'BaseException', 'BlockingIOError', 'BrokenPipeError', 
    'BufferError', 'BytesWarning', 'ChildProcessError', 'ConnectionAbortedError', 'ConnectionError', 'ConnectionRefusedError', 
    'ConnectionResetError', 'DeprecationWarning', 'EOFError', 'Ellipsis', 'EnvironmentError', 'Exception', 'False',
    'FileExistsError', 'FileNotFoundError', 'FloatingPointError', 'FutureWarning', 'GeneratorExit', 'IOError', 'ImportError', 
    'ImportWarning', 'IndentationError', 'IndexError', 'InterruptedError', 'IsADirectoryError', 'KeyError',
    'KeyboardInterrupt', 'LookupError', 'MemoryError', 'NameError', 'None', 'NotADirectoryError', 'NotImplemented', 
    'NotImplementedError', 'OSError', 'OverflowError', 'PendingDeprecationWarning', 'PermissionError', 'ProcessLookupError', 
    'ReferenceError', 'ResourceWarning', 'RuntimeError', 'RuntimeWarning', 'StopIteration', 'SyntaxError', 'SyntaxWarning', 
    'SystemError', 'SystemExit', 'TabError', 'TimeoutError', 'True', 'TypeError', 'UnboundLocalError', 'UnicodeDecodeError', 
    'UnicodeEncodeError', 'UnicodeError', 'UnicodeTranslateError', 'UnicodeWarning', 'UserWarning', 'ValueError', 'Warning', 
    'ZeroDivisionError', '__build_class__', '__debug__', '__doc__', '__import__', '__loader__', '__name__', '__package__', 
    '__spec__', 'abs', 'all', 'any', 'ascii', 'bin', 'bool', 'bytearray', 'bytes', 'callable', 'chr', 'classmethod', 
    'compile', 'complex', 'copyright', 'credits', 'delattr', 'dict', 'dir', 'divmod', 'enumerate', 'eval', 'exec', 'exit', 
    'filter', 'float', 'format', 'frozenset', 'getattr', 'globals', 'hasattr', 'hash', 'help', 'hex', 'id', 'input', 'int', 
    'isinstance', 'issubclass', 'iter', 'len', 'license', 'list', 'locals', 'map', 'max', 'memoryview', 'min', 'next', 
    'object', 'oct', 'open', 'ord', 'pow', 'print', 'property', 'quit', 'range', 'repr', 'reversed', 'round', 'set', 
    'setattr', 'slice', 'sorted', 'staticmethod', 'str', 'sum', 'super', 'tuple', 'type', 'vars', 'zip']
```
    
**Reglas para declarar Variables**
    
- No se pueden usar espacios
```python
con espacios = 1
```
- No usar un número delante
```python
1_numero = 1
```
- Válidos, pero no recomendado
```python
otraOpcion = 1
opcionCon123123 = 1
dame$ = 1
```
- Mejor usar snake_case para funciones, métodos, atributos y variables
```python
tipo_snake_case = 1
```
- Mejor usar mayúsculas en el caso de las constantes
```python
TIPO_CONSTANTE = 1
```
- Mejor usar camelCase en el caso de clases o código previamente definido así.
```python
CamelCase = 1
```

### Python: Entendiendo las variables de Python

**Estructuración**
- Secuenciales:
    - Son contenedores de elementos ordenados, se pueden recorrer haciendo uso del indice (números enteros positivos)
    - En esta categoria entran las cadenas, listas y tuplas
- Conjuntos:
    - Son contenedores de elementos ordenados, cada elemento puede ser de diferente tipo o igual.
    - En esta categoria entran las listas, tuplas y diccionarios
- Números:
    - Las variables de tipo numeral son tres. No existe un tipo de variable único para todos los números 

### Python: Tipos de variables


**Núlo**
- NoneType (como null en otros lenguajes)
```python
type(None)
```

**Números**
- Enteros
```python
type(23) #int - Base 10
type(0o27) #int - Octal
type(0x17 ) #int - Hexadecimal 
```
- Punto flotante
```python
type(0.2703) #float
type(0.1e-3) #float
```
- Complejos
```python
type(2.1 + 7.8j) #complex
```

**Cadenas**
```python
type("Texto entre comillas dobles") #str
type('Texto entre comillas simples') #str
type('Texto entre \n\tcomillas simples') #str
type("""Texto linea 1
linea 2
linea N
""") #str
type("Cadena" * 3) #str
```

**Booleanos**
```python
type(True) #bool
type(False) #bool
```

**Conjuntos**
- Lista
```python
type(['pan', 'huevos', 100, 1234]) #list - Listas (Array)
```
- Tupla
```python
type(('pan', 'huevos', 100, 1234)) #tuple - Tuplas (Array no modificable)
```
- Diccionario (mapping)
```python
type({
    "nombre":"Yo",
    "apellido":"Mismo"
}) #dict - Diccionario
```


### Python: Matemáticas Básicas
```python
    suma = 5 + 4
    resta = 10 - 6
    multiplicacion = 3 * 3
    division = 6 / 1.34 #Devulve float. complex si algún número lo era también
    division_entera = 6 // 1.34 #Devulve un integral, truncando la parte fraccional. round()
    potencia = 3 ** 2 
    negacion = -3 #No hace nada si es cero. Cambia el signo
    clarificar_codigo = +3 #No hace nada... solo se usa para esclarecer.
    modulo = 43 % 10
```

### Python: Matemáticas Básicas: Agrupaciones y Métodos útiles
```python
    expresion1 = (3 + 7) * 10
    expresion2 = (-56 * 6) - 74 * -25
    expresion3 = (3 * 3) + 10 - 12 / 2
    expresion4 = 44 + (83 % (33 + 100))
    expresion5 = -145 + (500 / 10 - 5) + 10 * 10
    valor_absoluto = abs(x) #Valor Absoluto
    calculo = divmod(x,y) #Devuelve el cociente por un lado y el resto por otro 
    otra_potencia = pow(3,2) #Igual que x**y
    expresion6 = pow(3,2,2) #Igual que (3 ** 2) % 2, pero más rápido
    redondeo1 = round(x, n) 
```

### Python: Matemáticas Básicas: crecimiento y decrecimiento
- En Python no existe *--* o *++*
```python
    numero = 5;
    
    numero -= 1
    print(numero)  #4
    numero += 1
    print(numero)  #5
```

### Python: Operadores de asignación
- *=* Asignación
```python
x = 1
y = 2
x = y
print("\"x\" vale ", x)
```

- *=* Asignación Múltiple
```python
a = b = c = 1
d, e, f = 2,False,"texto"

print("\"a\" vale ", a) #1
print("\"b\" vale ", b) #1
print("\"c\" vale ", c) #1
print("\"d\" vale ", d) #2
print("\"e\" vale ", e) #False
print("\"f\" vale ", f) #texto

# en una lista:
mi_lista = ['Fictizia', 'Madrid']
centro, provincia = mi_lista
print(centro)  # Fictizia
print(provincia)  # Madrid
```

- *+=* Suma
```python
x = 1
y = 2
x += y
print("\"x\" vale ", x) #x = x + y
```
- *-=* Resta
```python
x = 1
y = 2
x -= y
print("\"x\" vale ", x) #x = x - y
```
- _*=_ Multiplicar
```python
x = 1
y = 2
x *= y
print("\"x\" vale ", x) #x = x * y
```
- */=* Dividir
```python
x = 1
y = 2
x /= y
print("\"x\" vale ", x) #x = x / y
```

- *//=* División Entera
```python
x = 1
y = 2
x //= y
print("\"x\" vale ", x) #x = x // y
```
- _**=_ Potencia
```python
x = 1
y = 2
x **= y
print("\"x\" vale ", x) #x = x ** y
```
- *%=* Módulo
```python
x = 1
y = 2
x %= y
print("\"x\" vale ", x) #x = x % y
```

### Python: Operadores de pertenencia
Podemos comprobar si un elemento se encuentra o no en una colección como cadenas, listas y tuplas.

- **in**
```python
    builtins_list = dir(__builtins__)
    "AssertionError" in builtins_list   #true
    "Otra cosa...." in builtins_list    #false
```
- **not in**
```python
    builtins_list = dir(__builtins__)
    "AssertionError" not in builtins_list   #false
    "Otra cosa...." not in builtins_list    #true
```

### Python: Operadores de identidad
Verifica si ambos elementos se refieren al mismo objeto
- **is**
```python
a = 1
b = 1
print(a is b) #True
```
- **is not**
```python
a = 1
b = 100
print(a is not b) #True
```
- **is vs. =**
```python
a = [1, True, "Cadena"]
b = [1, True, "Cadena"]
print(a is b) #False
print(a == b) #True
```

### Python: Comparadores básicos

**Importante:** 
En Python la comparación entre elementos se hace con sus valor binario. Lo que elimina la necesidad que usar la igualación por valor y tipo ( === y !==)

```python
    mayor_que = 100 > 10
    menor_que = 10 < 100
    mayor_igual = 100 >= 10
    menor_igual = 10 <= 100
    igual = 10 == 10
    no_gual = 100 != 10
```

### Python: Comparadores complejos (Operadores lógicos)

- AND(&)
```python
    comparacion = True and True # True
    comparacion = True and False # False
    comparacion = False and False # False
    comparacion = False and True # False
    
    # Se puede utilizar & también
    comparacion = True & True # True
    comparacion = True & False # False
    comparacion = False & False # False
    comparacion = False & True # False
    
    # Fuera de un contexto boleano devuelve otros resultados
    tres = 3
    dos = 2
    conjunto = tres and dos
```
- OR(|)
```python
    comparacion = True or True # True
    comparacion = True or False # True
    comparacion = False or False # False
    comparacion = False or True # True
    
    # Se puede utilizar | también
    comparacion = True | True # True
    comparacion = True | False # True
    comparacion = False | False # False
    comparacion = False | True # True
```

- not
```python
    comparacion = True and not(False) # True
```

- Ejemplos
```python
    ex_1 = True & True #True
    ex_2 = (2 == 2) & (3 >= 6) #False
    ex_3 = (2>3) | (17 <= 40) #True
    ex_4 = False | False #False
```


### Python: Asignación por igualdad
```python
    administrador = 'Yo mismo'
    esAdministrador = (administrador == 'Yo mismo')
    print(esAdministrador)
```
    
### Python: If...
- **If solamente**
```python
    variable = 100
    if ( variable  == 100 ): 
        print("Valor 100")
```

- **If... en línea**
```python
    variable = 100
    if ( variable  == 100 ) : print("Valor 100")
```

- **Else**
```python
    condicion = True;
    if condicion:
        print("True, por eso me ejecuto")
    else:
        print("False, por eso me ejecuto")
```


### Python: elif...
```python
condicion = 100
if condicion == 100:
   print("If....", condicion)
elif condicion == 200:
   print("Elif....", condicion)
else:
   print("Else...", condicion)
```


### Python: Switch

![fun](https://pydanny.com/static/aliens.png)

No existe en Python
- [Switch alternativo](http://www.pydanny.com/why-doesnt-python-have-switch-case.html)


### Python: Simplificado
- Clásico
```python
    condition = True
    if condition:
        print('yes')
    else:
        print('nah')
```

- Alternativo (Operador Ternario)
```python
    condition = True
    print('yes') if condition else print('nah')
    # expresion_1 if condicion_true else expresion_2
```

- Encapsulamiento, como parte de una asignación
```python
    invitado = True
    comensales = 1 + 1 if invitado else 0 # ERROR! -> (2 o 0)
    comensales = 1 + (1 if invitado else 0) # CORRECTO! -> (2 o 1)
```


### Python: While
- Bucle infinito: Este es un error muy común.
```python
while True:
    print("Este texto se imprime hasta el infinito...")
```
- Bucle que no se ejecutará:
```python
while False:
    print("Este texto jamas se imprimirá...")
```
- Ejemplo
```python
count = 0
while (count <= 10):
    print('Vuelta:', count)
    count += 1

print('Fin del bucle!')
```


### Python: For... in
Específico para listas o cadenas de texto.

- **Estructura**
```python
for iterating_var in sequence:
   statements(s)
```

- **String**
```python
for letra in 'Fictizia':
   print('Letra actual :', letra)
```

- **Listas** 
```python
lista = ['pan', 'huevos', 100, 1234]
for elemento in lista:
   print('Elemento actual :', elemento)
```

- **Tuplas** 
```python
tupla = ('pan', 'huevos', 100, 1234)
for elemento in tupla:
   print('Elemento actual :', elemento)
```

- **Anidación**
    - Funciona en todos los casos
    ```python
    list_of_lists = [ [1, 2, 3], [4, 5, 6], [7, 8, 9]]
    for list in list_of_lists:
        for x in list:
            print(x) 
    ```
    - Funciona en aquellos casos donde las longitudes sean comunes (No recomendado)
    ```python
    super_lista = [(1, 2), (3, 4)]
    for i,j in super_lista:
        print("i:"+str(i)+", j:"+str(j)) 
    ```

- **Usando range()**
    - Permite controlar un bucle con una progresión aritmetica
    - *Start* y *Step* son opcionales
    - *Stop* determina el tope del rango, el último valor incluido es Parar-1
    - Al incluir *Step*... también debemos incluir *Start*, pero no al revés
    - Estructura: `range([Start = 0], Stop, [Step = 1])`
    - Ejemplos:
        - Definiendo solo el máximo
        ```python
        for i in range(3):
            print("Vuelta número: %d" % (i))
        ```
        - Definiendo el mínimo
        ```python
        for i in range(3, 10):
            print("Vuelta número: %d" % (i))
        ```
        - Alterando el paso
        ```python
        for i in range(3, 10, 2):
            print("Vuelta número: %d" % (i))
        ```

### Python: Do... While
No existe en Python

- Alternativa
```python
while True:
  # Código.... 
  if False:
    break
```
- Ejemplo
```python
i = 0
while True:
    i += 1;
    print("Vuelta: ", i)
    if i < 10:
        break
```

- Alternativas:
	- [Emular Do... While en Python](http://stackoverflow.com/questions/743164/emulate-a-do-while-loop-in-python) 


### Python: Break y Continue
- **Continue** 
    - nos permite saltar parte del bucle.
    ```python
    for i in range (2):
        print("[Vuelta %d] esto va antes del continue!" % (i))
        continue
        print("esto va después del continue!")
    ```
    ```python
    count = 0
    while (count <= 10):
        count += 1
        if count == 5:
            continue
        print('Vuelta:', count)
    ```
- **Break**
    - nos permite salir del bucle.
    ```python
    count = 0
    while (count <= 10):
        count += 1
        if count == 5:
            break
        print('Vuelta:', count)
    ```

### Python: Usos Avanzados

**Else**
- Funciona con *for* y con *while*
- Se ejecutará cuando la condicción del bucle ya no sea *True*
- Existen excepciones como *ValueError*, *break*, *return* que evitaran que se ejecute el *else*
```python
count = 0
while (count <= 10):
    print('Vuelta:', count)
    count += 1
else:
    print('Fin del bucle!')
```


### Python: Números

**Tipos**
- Enteros
```python
type(23) #int - Base 10
type(0o27) #int - Octal
type(0x17 ) #int - Hexadecimal 
```
- Punto flotante
```python
type(0.2703) #float
type(0.1e-3) #float
```
- Complejos
```python
type(2.1 + 7.8j) #complex
```

**Conversión de Enteros**
```python
numero = 1626519864
numero_binario = bin(numero)
numero_hexadecimal = hex(numero)
numero_entero = int(1626519864.165)
numero_octal = oct(numero)
```

### Python: Módulo Math
- Es un módulo ideado para realizar operaciones matemáticas y científicas

**Importando**
```python
import math
print(math.pi)
```

**Números-teóricos y funciones representativas**
- `math.ceil(x)` *Retorna el techo*
- `math.copysign(x, y)` *Retorna un número flotante con el valor absoluto de x, pero el signo de y*
- `math.fabs(x)` *Retorna el valor absoluto*
- `math.factorial(x)` *Retorna el factorial o un error si no es entero o negativo*
- `math.floor(x)` *Retorna el máximo entero menor o igual a un número*
- `math.fmod(x, y)` *Retorna `fmod(x, y)` como se define en la librería de C*
- `math.frexp(x)` *Retorna la mantisa y exponente como el par `(m , e)`*
- `math.fsum(iterable)` *Retorna la suma (punto flotante) precisa de los valores en la lista/tupla...*
- `math.gcd(a, b)` *Retorna el máximo común divisor*
- `math.isclose(a, b, *, rel_tol=1e-09, abs_tol=0.0)` *Verifica la cercanía entre dos números*
- `math.isfinite(x)` *(Desde v3.2) Verifica si no es ni infinito ni un NaN. 0.0 se considera infinito*
- `math.isinf(x)` *Verifica si es un núnmero infinito*
- `math.isnan(x)` *Verifica si es NaN*
- `math.ldexp(x, i)` *Retorna `x * (2**i)`*
- `math.modf(x)` *Retorna las partes fraccionarias y enteros*
- `math.trunc(x)` *Retorna el valor real truncado a una integral (número entero casi siempre)*

**Potencias y funciones logarítmicas**
- `math.exp(x)` *Retorna `e**x`*
- `math.expm1(x)` *Retorna `e**x - 1`*
- `math.log(x[, base])` *Retorna el logaritmo natural o con la base especificada `log(x)/log(base)`*
- `math.log1p(x)` *Retorna el logaritmo natural de 1+x (base e)*
- `math.log2(x)` *Retorna el logaritmo de base-2*
- `math.log10(x)` *Retorna el logaritmo de base-10*
- `math.pow(x, y)` *Retorna x elevado a la potencia de y*
- `math.sqrt(x)` *Retorna la raiz cuadrada*

**Funciones trigonométricas**
- `math.acos(x)` *Retorna arco coseno en radianes*
- `math.asin(x)` *Retorna arco seno en radianes*
- `math.atan(x)` *Retorna la tangente en radianes*
- `math.atan2(y, x)` *Retorna `atan(y / x)`, en radianes*
- `math.cos(x)` *Retorna el coseno*
- `math.hypot(x, y)` *Retorna la [norma euclidiana](https://www.wikiwand.com/es/Norma_vectorial)*
- `math.sin(x)` *Retorna el seno*
- `math.tan(x)` *Retorna la tangente*


**Conversión Angular**
- `math.degrees(x)` *Convierte de radianes a grados*
- `math.radians(x)` *Convierte de grados a radianes*

**Funciones hiperbólicas**
- `math.acosh(x)` *Retorna el coseno hiperbólico inverso*
- `math.asinh(x)` *Retorna el seno hiperbólico inverso*
- `math.atanh(x)` *Retorna la tangente hiperbólica inversa*
- `math.cosh(x)` *Retorna el coseno hiperbólico*
- `math.sinh(x)` *Retorna el seno hiperbólico*
- `math.tanh(x)` *Retorna la tangente hiperbólica*
 

**Funciones Especiales**
- `math.erf(x)` *(Desde v3.2) Retorna la [función error de Gauss](https://www.wikiwand.com/es/Funci%C3%B3n_error)*

![funcion](https://wikimedia.org/api/rest_v1/media/math/render/svg/8e659db8ac65279291e40733a160d895de0a9d98)
    
Se puede utilizar para funciones estadísticas
```python
def phi(x):
    'Cumulative distribution function for the standard normal distribution'
    return (1.0 + erf(x / sqrt(2.0))) / 2.0
```

- `math.erfc(x)` *(Desde v3.2) Retorna la [función error complementaria](https://www.wikiwand.com/es/Funci%C3%B3n_error)*

![funcion](https://wikimedia.org/api/rest_v1/media/math/render/svg/6e747e89de81a43b059918bfc5cdf9c892d1c86c)

- `math.gamma(x)` *(Desde v3.2) Retorna la [función Gamma](https://www.wikiwand.com/es/Funci%C3%B3n_gamma)*

![funcion](https://wikimedia.org/api/rest_v1/media/math/render/svg/2e33f1b6a1c65ad229ffec6865892bfa178dbad9)

- `math.lgamma(x)` *(Desde v3.2) Retorna el logaritmo natural del valor absoluto de la función gamma para x*


**Constantes**
- `math.pi` *π = 3.141592653589793*
- `math.e` *e = 2.718281828459045*
- `math.inf` *(Desde v3.5) Flotante. infinito negativo*
- `-math.inf` *(Desde v3.5) Flotante. infinito negativo*
- `math.nan` *(Desde v3.5) Flotante. Not A Number*


### Python: Módulo Cmath
- Es muy similar al *módulo math*, pero pensado para números complejos 
- [Documentación completa](https://docs.python.org/3/library/cmath.html)


### Python: Módulo Statistics
- Modulo pensado para la gestion y calculo estadistico
    - Promedios y medidas de tendencia central
    - Medidas de difusión
    - Otras funciones...
- [Documentación completa](https://docs.python.org/3/library/statistics.html)


### Python: Módulo Fractions
- Módulo ideado para la gestión de Números racionales (fracciones)
- [Documentación completa](https://docs.python.org/3/library/fractions.html)


### Python: Modulo Random
- Es un módulo especializado para lidiar con el azar.

**Importar el módulo**
```python
import random
```

**Métodos útiles**

- .randrange ([empieza=0,] termina [,paso=1]) *Retorna un numero al azar entre un rango determinado por nosotros*
```python
import random
print ("Entre 0-99:", random.randrange(100)) # 43
print ("Entre 10-40 (Pares):", random.randrange(10, 40, 2)) # 22
print ("Entre 11-33 (Impares):", random.randrange(11, 33, 2)) # 25
```

- .choice(lista) *Retorna un elemento al azar de una lista/tupla/cadena...*
```python
import random
fruta = random.choice(["Plátano", "Manzana", "Pera", "Kiwi"])
print(fruta)                        # Plátano
print(random.choice("Fictizia"))    # c
```

- .random() *Retorna un decimal aleatorio entre 0.0 y 1.0*
```python
import random
print("El azar dice", random.random()) # El azar dice 0.7689059637144342
```

- .shuffle(lista) *Reordena al azar los elementos de una lista*
```python
import random
lista = [2, 1, 16, 12, 45, 23,];
random.shuffle(lista)
print ("lista Reordenada:",  lista) # lista Reordenada: [23, 1, 2, 12, 16, 45]
```


- .uniform(minimo, maximo) *Retorna un decimal aleatorio entre el mínimo y máximo definido por nosotros*
```python
import random
print("El azar dice", random.uniform(5, 7)) # El azar dice 6.638733973842519
```

- .randint(minimo, maximo) *Retorna un entero aleatorio entre el mínimo y máximo definido por nosotros*
```python
import random
print("Tirada de dado (6 caras): ", random.randint(1, 6)) #3
print("Tirada de dado (20 caras): ", random.randint(1, 20)) #13
```


### Python: Módulo Decimal
- Creando decimales inmutables, con precisión
- Creando decimales
- Módulo muy extenso en métodos.
    - [Documentación completa](https://docs.python.org/3/library/decimal.html) 
```python
import decimal
decimal_1 = decimal.Decimal(32)
decimal_2 = decimal.Decimal(12.1238615234715283987639162398126374517235412034230486)
print(decimal_1 + decimal_2) # 44.12386152347152901143090276
```
- Comparando con Float
```python
import decimal
print("Version Float: ", 23 / 1.03) #22.33009708737864
print("Versión Decimal: ", decimal.Decimal(23) / decimal.Decimal(1.03)) #22.33009708737864019903562108
```


### Python: Python aplicado a la Ciencia

**Más información**
- [Python + Ciencia = \o/ (PyConES 2013)](https://www.youtube.com/watch?v=FnU0EYi63fI))
- [Presentando Sage, software matemático basado en Python (PyConES 2013)](https://www.youtube.com/watch?v=pNQPyolDyL4)
- [Learn Python for Science - NumPy, SciPy and Matplotlib de Shane Neeley](https://www.youtube.com/watch?v=oYTs9HwFGbY)
- [Introducción a Python para científicos e ingenieros](https://www.youtube.com/watch?v=1wKfeTqN8qQ)

**Módulos de la comunidad**
- [numpy](http://www.numpy.org/)
- [scipy](https://www.scipy.org/)
- [matplotlib](http://matplotlib.org/)



### Python: Módulo Time

**Importar el módulo**
```python
import time
```

**Métodos útiles**

- .time([hour[, minute[, second[, microsecond[, tzinfo]]]]]) *Creamos una fecha especifica o la actual*
```python
import time
print("Hora actual desde 01/01/70 a las 00:00 - ", time.time()) # 1470359626.8825448
```

- .localtime([segundos]) *Retorna una TimeTuple*

Posición     | Campo         | Valores
------------ | ------------- | -------------
0 | Año | 2016
1 | Mes | 1 - 12
2 | Día | 1 - 31
3 | Hora | 0 - 23
4 | Minuto | 0 - 59
5 | Segundo | 0 - 61 (61 bisiestos)
6 | Día de la semana | 0 - 6 (0 es Lunes)
7 | Día del año | 1 - 366
8 | Horario de verano | -1, 0, 1, -1 DST

```python
import time
print("Tiempo Local - ", time.localtime()) 
# time.struct_time(tm_year=2016, tm_mon=8, tm_mday=5, tm_hour=1, tm_min=15, tm_sec=27, tm_wday=4, tm_yday=218, tm_isdst=0)
```

- .asctime() *Formateando el tiempo*
```python
import time
print("asctime:", time.asctime( time.localtime(time.time()))) 
# asctime:  Fri Aug  5 01:25:46 2016
```

- .altzone() *Offset local en segudnos*
```python
import time
print("altzone:", time.altzone) # 0
```

- .clock() *benchmarking - Tiempo de procesamiento*
```python
import time

def procedure():
    time.sleep(5)

t0 = time.clock()
procedure()
print (time.clock() - t0, "- benchmark") # 0.0010940000000000116
```

- .ctime([segundos]) *Convierte el tiempo en una cadena representable*
```python
import time
print("ctime:", time.ctime()) # ctime: Fri Aug  5 01:41:53 2016
```

- .gmtime([segundos]) *Convierte el tiempo en una DateTuple UTC*
```python
import time
print ("gmtime :", time.gmtime(1470359626.8825448))
# gmtime : time.struct_time(tm_year=2016, tm_mon=8, tm_mday=5, tm_hour=1, tm_min=13, tm_sec=46, tm_wday=4, tm_yday=218, tm_isdst=0)
```

- .sleep(segundos) *Suspende la ejecucción por un número deteminado de segundos *
```python
import time
print("Empezamos el suspenso...")
time.sleep(5)
print("Termino el suspenso...")
```

- .strftime(formato [, segundos]) *Nos permite customizar la resprsentación del tiempo como cadena*

Ref          | Valor        
------------ | -------------
%a | Nombre del día de la semana abreviado
%A | Nombre del día de la semana completo
%b | Nombre del mes abreviado
%B | Nombre del mes completo
%c | preferred date and time representation
%C | Centuria (Año dividido por 100, 00 - 99)
%d | Día del mes (01 - 31)
%D | Lo mismo que %m/%d/%y
%e | Día del mes (1 - 31)
%g | Como %G, pero sin centuria
%G | Año en 4-digitos correspondiente al número de semana ISO (ver %V).
%h | Igual que %b
%H | Hora, formato 24h (00 - 23)
%I | Hora, formato 12h (01 - 12)
%j | Día del año (001 - 366)
%m | Mes (01 - 12)
%M | Minuto
%n | Salto de línea
%p | AM o PM en función de la hora
%r | Tiempo en formato a.m. y p.m.
%R | Tiempo en formato 24h
%S | Segundos
%t | Tabulación Horizontal
%T | Tiempo actual, igual que %H:%M:%S
%u | Día de la semana como numero (1 - 7), Lunes=1 o Domingo=1, en función del tipo de calendario
%U | Número de semana del año actual, empezando por el primer domingo del año como primera semana
%V | El número de semana del año actual según el ISO 8601 (01 - 53), la primera semana es la priemra semana que tenga cuatro días en el año actual, y el Lunes como primer día de la semana
%W | Número de semana del año actual, contando desde el primer lunes de la primera semana
%w | Día de la semana decimal, Domingo=0
%x | Represetnación de fecha preferida sin hora
%X | Represetnación de hora preferida sin fecha
%y | Año sin la centuria (00 - 99)
%Y | Año incluyendo la centuria
%Z | Zona Horaria o nombre o abreviación
%z | Igual que %Z 
%% | Caracter %

```python
import time
print (time.strftime("Semana %U - %b %d %Y %H:%M:%S", time.localtime())) # Semana 31 - Aug 05 2016 02:14:41
```

- .strptime(cadena_fecha [, formato]) *Retorna una fecha cuando introduccimos una cadena y descodificarla usando los formatos como strftime*
```python
import time
estructurado = time.strptime("Semana 31 - Aug 05 2016 02:14:41", "Semana %U - %b %d %Y %H:%M:%S")
print ("DateTuple:", estructurado)
# time.struct_time(tm_year=2016, tm_mon=8, tm_mday=5, tm_hour=2, tm_min=14, tm_sec=41, tm_wday=4, tm_yday=218, tm_isdst=-1)
```


### Python: Módulo calendar


**Importar el módulo**
```python
import calendar
```

**Métodos útiles**

- .month(year, month) *Creamos un calendario*
```python
import calendar
print(calendar.month(2017, 1)) 
#     January 2017
# Mo Tu We Th Fr Sa Su
#                    1
#  2  3  4  5  6  7  8
#  9 10 11 12 13 14 15
# 16 17 18 19 20 21 22
# 23 24 25 26 27 28 29
# 30 31
```

**Librerías interesantes**
- [Arrow](http://crsmithdev.com/arrow/)
- [fleming](https://github.com/ambitioninc/fleming)
- [World Timezone Definitions for Python](http://pytz.sourceforge.net/)
- [Moment](https://github.com/zachwill/moment)
- [mxDateTime](http://www.egenix.com/products/python/mxBase/mxDateTime/)
- [dateutil](https://github.com/dateutil/dateutil)
- [Delorean](https://github.com/myusuf3/delorean)


### Python: Hora y Fecha en la practica


**datetime el módulo clave**
```python
from datetime import datetime, date, time, timedelta
```

**Fecha y hora actual**

```python
from datetime import datetime
ahora = datetime.now()
print("Reloj:", ahora)               # Reloj: 2016-08-05 14:26:50.472811
print("Reloj (UTC):",ahora.utcnow()) # Reloj (UTC): 2016-08-05 14:26:50.474835

print("*******Detalles********")
print("Día:",ahora.day)              # Día: 5
print("Mes:",ahora.month)            # Mes: 8
print("Año:",ahora.year)             # Año: 2016
print("Hora:", ahora.hour)           # Hora: 14
print("Minutos:",ahora.minute)       # Minutos: 26
print("Segundos:", ahora.second)     # Segundos: 50
print("Ms:",ahora.microsecond)       # Ms: 472811
```

**Operar con fechas**
```python
from datetime import  date, timedelta

print("Ayer:", date.today() - timedelta(days=1))
print("Hoy:", date.today())
print("Mañana:", date.today() + timedelta(days=1))

tomorrow = date.today() + timedelta(days=1)
yesterday = date.today() - timedelta(days=1)
difference = tomorrow - yesterday

print("The difference is", difference) # The difference is 2 days, 0:00:00
print("La diferencia es de", difference.days, "días") # La diferencia es de 2 días
```

**Comparación de horas**
```python
from datetime import time

hora1 = time(12, 10, 25) 
hora2 = time(15, 9, 59) 

print("hora1 =", hora1) # 12:10:25
print("hora2 =", hora2) # 15:09:59
print("...es hora1 mayor que hora2?", hora1 < hora2)  # True
```

**Comparación de fechas**
```python
from datetime import date

fecha1 = date.today()
fecha2 = date.today() + timedelta(days=2)  

print("fecha1 =", fecha1) # 2016-08-05
print("fecha2 =", fecha2) # 2016-08-07
print("...es fecha1 mayor que fecha2?", fecha1 > fecha2)  # False
```


### Python: Cadenas
Tipos de cadenas y escapes
- Comillas simples
```python
simples = 'Esto son comillas \'simples\' y esto "dobles"'
```
- Comillas dobles
```python
dobles = "Esto son comillas \"dobles\" y esto 'simples'"
```
- Comillas triples
```python
triples = """Esto es \"\"\"triple\"\"\"... esto "doble"
y esto 'simple'. Además ...
guarda el formato!"""
```

- Alternativas a triple comilla
```python
alternativa_1 = "una línea...." + \
"otra línea..."
alternativa_2 = ("Una línea"
"Otra línea....")
```

### Python: Cadenas: Codificación

- Codificación UTF-8
```python
euro = "€" 
```
- Uso Unicode
```python
euro = "\u20AC"
euro = "\U000020AC"
```

### Python: Cadenas: Secuencias
- Es necesario manejar número enteros
- **Estructura**
```python
sec[inicio]
sec[inicio:fin]
sec[inicio:fin:paso]
``` 
- Ejemplos
```python
trozo = "Fictizia"[2] #c
trozo = "Fictizia"[-3] #z
trozo = "Fictizia"[-3:-1] #zi
trozo = "Fictizia"[1:-3] #icti
trozo = "Fictizia"[1:-3:2] #it
trozo = "Fictizia"[::2] #Fcii
trozo = "Fictizia"[::-2] #azti
``` 
- Paso a paso
``` 
 +---+---+---+---+---+---+---+---+
 | F | i | c | t | i | z | i | a |
 +---+---+---+---+---+---+---+---+
 0   1   2   3   4   5   6   7   
-8  -7  -6  -5  -4  -3  -2  -1
``` 

### Python: Cadenas: Métodos

- .capitalize() *Retorna la primera letra en mayúscula*
```python
"fictizia".capitalize() #Fictizia
```

- .center(longitud [, caracter]) *Retorna una cadena nueva con el texto original en el centro y los laterales rellenados*
```python
"fictizia".center(20) #      fictizia      
"fictizia".center(20, "-") #------fictizia------
```

- .count(cadenaBuscada [, empieza=0, termina=len(string)]) **
```python
"Fictizia".count("i") # 3
"Fictizia".count("zia") # 1
"Fictizia".count("i", 5, 7) # 1
```

- .encode(encoding, errores) *Retorna una versión codificada de la cadena original*
 - *errores* especifica el manejo del error. Recomendado *strict*	e *ignore*.[Manejo de errores en Python 3.x](https://docs.python.org/3/library/codecs.html#error-handlers)
 - *encoding* especifica la coficicación. [Lista de codigficaciones disponibles](https://docs.python.org/3/library/codecs.html#standard-encodings) 
```python
"Fictizia".encode('ascii','strict') # b'Fictizia'
```

- .decode(encoding, errores) *Retorna una versión decodificada de la cadena original*
 - *errores* especifica el manejo del error. Recomendado *strict*	e *ignore*.[Manejo de errores en Python 3.x](https://docs.python.org/3/library/codecs.html#error-handlers)
 - *encoding* especifica la coficicación. [Lista de codigficaciones disponibles](https://docs.python.org/3/library/codecs.html#standard-encodings) 
```python
b'Fictizia'.decode('utf-8','strict') # Fictizia
```

- .endswith(criterio [, empieza[, termina]]) *Retorna True si la cadena termina con cierto criterio. False si no coincide*
 - *Criterio* Determina lo que buscamos, puede ser una cadena de texto o una tupla.
 - *Empieza* opcional. Especifica el principio del tramo
 - *Termina* opcional. Especifica el fin del tramo
```python
"Fictizia".endswith("a") # True
"Fictizia".endswith("zi", 5 , 7) # True
"Fictizia".endswith(("zi", "a")) # True
"Fictizia".endswith(("zi", "a"), 5 , 7) # True
```

- .expandtabs(size) *Retorna una versión de la cadena donde los \t se convierten en espacios definidos por nosotros*
```python
(6*"Fictizia\t").expandtabs(4) # Fictizia    Fictizia    Fictizia...   
```

- .find(criterio [, inicio[, fin]]) *Retorna la posición del criterio o -1 si no lo encuentra*
```python
"Fictizia".find("zi") # 5
"Fictizia".find("yo") # -1
```

- .index(criterio [, inicio[, fin]]) *Similar a find(), pero si no encuentra lanza un error*
```python
"Fictizia".index("zi") # 5
"Fictizia".index("yo") # ValueError: substring not found
```

- .isalnum() *Verifica si es alfanumerico*
```python
"Fictizia".isalnum() # True
"#Fictizia".isalnum() # False
```

- .isalpha() *Verifica si es un carácter alfanumerico*
```python
"Fictizia".isalpha() # True
"123".isalpha() # False
```

- .isdigit() *Verifica si es un dígito alfanumerico*
```python
"Fictizia".isdigit() # False
"123".isdigit() # True
```

- .islower() *Verifica si esta en minúsculas*
```python
"Fictizia".islower() # False
"fictizia".islower() # True
```

- .isupper() *Verifica si esta en Mayúsculas*
```python
"Fictizia".isupper() # False
"FICTIZIA".isupper() # True
```

- .isnumeric() *Verifica si es un dígito alfanumerico*
```python
"Fictizia".isnumeric() # False
"123".isnumeric() # True
```

- .isspace() *Verifica una cadena consiste unicamente de espacios en blanco*
```python
"Fictizia".isspace() # False
"Fictizia   Fictizia".isspace() # False
"     ".isspace() # True
```

- .istitle() *Verifica si cada una de las palabras que componene la cadena empeiza por mayuscula y el resto no*
```python
"Fictizia Fictizia".istitle() # True
"Fictizia fictizia".istitle() # False
"Fictizia FICTIZIA".istitle() # False
```

- .isdecimal() *Verifica si una cadena consiste unicamente de decimales.*
```python
"00215487521".isdecimal() # True
"123456789".isdecimal() # True
"1a123".isdecimal() # False
```

- .join(secuencia) *Retorna una cadena que concatena los elementos de una tupla o lista con un criterio*
```python
"-".join(("aaa", "b", "CCCC")) # aaa-b-CCCC
"*".join(["A", "Z", "D"]) # A*Z*D
```

- len(cadena) *Retorna la longitud de una cadena*
```python
len("Fictizia") # 8
```

- .ljust(longitud[, relleno]) *Retorna una cadena justificada a la izquierda, criterio de relleno opcional*
```python
"Fictizia".ljust(12) # 'Fictizia    '
"Fictizia".ljust(15, '*') # Fictizia*******
```

- .rjust(longitud[, relleno]) *Retorna una cadena justificada a la derecha, criterio de relleno opcional*
```python
"Fictizia".rjust(12) # '    Fictizia'
"Fictizia".rjust(15, '*') # *******Fictizia
```


- .lower() *Retorna una cadena con todas las letras en minúsculas*
```python
"Fictizia".lower() # fictizia
```

- .upper() *Retorna una cadena con todas las letras en mayúsculas*
```python
"fictizia".upper() # FICTIZIA
```

- .lstrip([caracter]) *Retorna una cadena con los espacios en blanco de la izquierda eliminados, u otro caracter*
```python
"      Fictizia".lstrip() # Fictizia
"===Fictizia===".lstrip() # ===Fictizia===
"===Fictizia===".lstrip("=") # Fictizia===
```

- .strip([caracter]) *Retorna una cadena con los espacios en blanco eliminados, u otro caracter*
```python
"      Fictizia    ".strip() # Fictizia
"===Fictizia===".strip() # ===Fictizia===
"===Fictizia===".strip("=") # Fictizia
```

- .rstrip([caracter]) *Retorna una cadena con los espacios en blanco de la derecha eliminados, u otro caracter*
```python
"Fictizia      ".rstrip() # Fictizia
"===Fictizia===".rstrip() # ===Fictizia===
"===Fictizia===".rstrip("=") # ===Fictizia
```

- .maketrans(originales, nuevos) y translate() *sustituye unos caracteres por otros. Retorna una cadena con los valores sustituidos*
```python
original = "Fictizia"
cambio = original.maketrans("ia", "1@") #{105: 49, 97: 64}
modificado = original.translate(cambio) # F1ct1z1a
print(original+" es "+modificado) # Fictizia es F1ct1z1@
```

- max() *Retorna el caracter alfabetico más alto en una cadena*
```python
max("Fictizia") # z
```

- min() *Retorna el caracter alfabetico más bajo en una cadena*
```python
min("Fictizia") # F
min("FictiziA") # A
min("fictizia") # a
min("fictizia.") # .
```

- .replace(viejo, nuevo [, maximo]) *Retorna una cadena con el remplazo *
```python
"Fictizia".replace("ia", "IA") # FictizIA
```

- .rfind(secuencia, [, inicio[, fin]]) *Retorna la posición de la última coincidencia o -1*
```python
"Fictizia".rfind("i") # 6
"Fictizia".rfind("q") # -1
```

- .rindex(secuencia, [, inicio[, fin]]) *Igual que frind() peor retorna un error en caso negativo*
```python
"Fictizia".rindex("i") # 6
"Fictizia".rindex("q") # ValueError: substring not found
```

- .split(criterio, [, maximo]) *Retorna una lista con los trozos divididos por el criterio*
```python
"Fictizia".split("i") # ['F', 'ct', 'z', 'a']
"Fictizia Fictizia".split() # ['Fictizia', 'Fictizia']
```

- .splitlines() *Retorna una lista con las líneas*
```python
"Una línea\n otra\n más míneas...".splitlines() # ['Una línea', ' otra', ' más míneas...']
```

- .startswith(secuencia, [, inicio[, fin]) *Verifica si un texto empieza por...*
```python
"Fictizia".startswith("F") # True
"Fictizia".startswith("i") # False
```

- .swapcase() *Retorna una cadena con las mayúsculas y minúsculas invertidas*
```python
"Fictizia".swapcase() # fICTIZIA
```

- .title() *Retorna una cadena con las primera letra de cada palabra en mayúsculas, el resto en minúsculas*
```python
"fICTIZIA".title() #Fictizia
```

- .zfill(tope) *Rellena con ceros a la izquierda hasta un tope (incluyendo el largo de la cadena original)*
```python
"Fictizia".zfill(10) # 00Fictizia (8+2)
```

### Python: Listas

- Creando una lista:
```python
listaVacia = []
lista = [1, "platano", "piscina", "manzana", True]
```

- Usando el Índice:
```python
lista = [1, "platano", "piscina", "manzana", True]
print("lista[0]: ", lista[0]) # 1
print("lista[1:2]: ", lista[1:2]) # ['platano']
print("lista[2:4]: ", lista[2:4]) # ['piscina', 'manzana']
```

- Cambiar un valor del Índice:
```python
lista[0] = "fresa"
lista[4] = "pera"
lista[2] = "limón"
print("lista[0:4]: ", lista[0:4]) # ['fresa', 'platano', 'limón', 'manzana']
```

- Borrando elementos
```python
print("lista: ", lista) # ['fresa', 'platano', 'limón', 'manzana', 'pera']
del lista[0]
del lista[3]
print("lista: ", lista) # ['platano', 'limón', 'manzana']
```

**Operaciones Básicas**
- Longitud
```python
len(lista) # 3
```

- Concatenación
```python
lista1 = [1, "platano"]
lista2 = ["piscina", "manzana", True]
lista = lista1 + lista2 # [1, 'platano', 'piscina', 'manzana', True]
```

- Repetición
```python
lista1 = [1, "platano"]
lista = lista1 * 5 # [1, 'platano', 1, 'platano', 1, 'platano', 1, 'platano', 1, 'platano']
```

- Pertenencía
```python
lista2 = ["piscina", "manzana", True]
print("Tenemos piscina?: ", "piscina" in lista2) # True
print("Tenemos agua?: ", "agua" in lista2) # False
```

- Iteración
```python
lista = ["piscina", "manzana", True]
for i in lista : 
    print("Elemento de la lista:", i)
```


**Propiedades**

- max(lista) *Retorna el mayor elemento de la lista*
```python
lista = [123, 234, 345, 456, 1, 500, 503, 1000]
max(lista) # 1000
```

- min(lista) *Retorna el menor elemento de la lista*
```python
lista = [123, 234, 345, 456, 1, -500, 503, 1000]
min(lista) # -500
```

- tuple(lista) *Convierte una lista en tupla*
```python
datos = [123, 234, 1000]
print("datos es...?", type(datos)) # <class 'list'>
datos = tuple(datos)
print("datos es...?", type(datos)) # <class 'tuple'>
```


**Métodos**

- .count(elemento) *Cuantas veces se repite un elemento en la lista*
```python
lista = [123, 234, -5, 345, 456, 1, -5, 503, 1000]
lista.count("Platano") # 0
lista.count(-5) # 2
```

- .extend(elemento) *Extiende cierto contenido a una lista*:
```python
lista = [1, 2, 3]
lista.extend([4, 5])
print ("Lista:", lista) # Lista: [1, 2, 3, 4, 5]
```

- .index(elemento) *Retorna la posición o un error de un elemento*:
```python
lista = [1, 2, 3]
print ("donde esta 2?:", lista.index(2)) # 1
print ("donde esta \"platano\"?:", lista.index("platano")) # ValueError: 'platano' is not in list
```

- .append(elemento) *Añadir elemento al índice (Final)*:
```python
lista.append("nuevo");
```

- .insert(posicion, elemento) *Añadir un elemento en una posición concreta*:
```python
lista = [1, 2, 3]
lista.insert(1, "nuevo") # [1, 'nuevo', 2, 3]
```

- .pop([posicion]) *Eliminar el último o un elemento de la lista y lo retorna*:
```python
lista = [1, 2, 3, "platano", "piscina", True]
lista.pop() # True
platanito = lista.pop(3) # platano
```

- .remove(elemento) *Eliminar un elemento de la lista*:
```python
lista = [1, 2, 3, "platano", "piscina", True]
lista.remove("platano") # [1, 2, 3, 'piscina', True]
lista.remove(5) # ValueError: list.remove(x): x not in list
```

- .reverse() *Altera el orden de una lista*:
```python
lista = [1, 2, 3, "platano", "piscina", True]
lista.reverse() # [True, 'piscina', 'platano', 3, 2, 1]
```

- .sort([func]) *Ordenar la lista*:
```python
frutas = ['Platano', 'Naranja', 'Limón', 'Manzana', 'Mango']
frutas.sort() # ["Limón", "Mango", "Manzana", "Naranja", "Platano"]
	
lista = ['uno', 2, True, 'más datos...']
lista.sort() # TypeError: unorderable types: int() < str()
```

### Python: Matrices
- Listas anidadas
```python
matriz = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
print(matriz[1]) # [4, 5, 6]
print(matriz[1][2]) # 6
```

### Python: Tuplas
Importante: Las tuplas son listas inmutables

- Creando una lista:
```python
tuplaVacia = ()
tupla = (1, "platano", "piscina", "manzana", True)
```

- Usando el Índice:
```python
tupla = (1, "platano", "piscina", "manzana", True)
print("tupla[0]: ", tupla[0]) # 1
print("tupla[1:2]: ", tupla[1:2]) # ['platano']
print("tupla[2:4]: ", tupla[2:4]) # ['piscina', 'manzana']
```

- Actualizar una tupla:
```python
tupla = (1, "platano", "piscina", "manzana", True)
tupla = ('fresa', 'platano', 'limón', 'manzana', 'pera')
```

- Borrando una tupla
```python
tupla = ('fresa', 'platano', 'limón', 'manzana', 'pera')
del tupla
print("tupla?", tupla) # NameError: name 'tupla' is not defined
```

**Operaciones Básicas**
- Longitud
```python
tupla = ('fresa', 'platano', 'limón', 'manzana', 'pera')
len(tupla) # 5
```

- Concatenación
```python
tupla1 = (1, "platano")
tupla2 = ("piscina", "manzana", True)
tupla = tupla1 + tupla2 # (1, 'platano', 'piscina', 'manzana', True)
```

- Repetición
```python
tupla1 = (1, "platano")
tupla = tupla1 * 5 # (1, 'platano', 1, 'platano', 1, 'platano', 1, 'platano', 1, 'platano')
```

- Pertenencía
```python
tupla = ("piscina", "manzana", True)
print("Tenemos piscina?: ", "piscina" in tupla) # True
print("Tenemos agua?: ", "agua" in tupla) # False
```

- Iteración
```python
tupla = ("piscina", "manzana", True)
for i in tupla : 
    print("Elemento de la tupla:", i)
```


**Propiedades**

- max(lista) *Retorna el mayor elemento de la lista*
```python
lista = [123, 234, 345, 456, 1, 500, 503, 1000]
max(lista) # 1000
```

- min(lista) *Retorna el menor elemento de la lista*
```python
lista = [123, 234, 345, 456, 1, -500, 503, 1000]
min(lista) # -500
```

- list(tupla) *Convierte una tupla en lista*
```python
datos = (123, 234, 1000)
print("datos es...?", type(datos)) # <class 'tuple'>
datos = list(datos)
print("datos es...?", type(datos)) # <class 'list'>
```


### Python: Sets
- Es una colación de datos desordenada
- No permite datos duplicados
- Se pueden utilizar para eliminar elementos repetidos en otra colección de datos
```python
vacio = set() #
cadena = set("Fictizia") # {'a', 'F', 'z', 'i', 't', 'c'}
lista = set([2,2,2,21,1,3,4,5]) # {1, 2, 3, 4, 5, 21}
```
- Se pueden utilizar el mismo principio con varios sets 
```python
set1 = set("Fictizia")
set2 = set("Python y Django")

print("Elementos únicos en 'set1':", set1) # Elementos únicos en 'set1': {'a', 'F', 'z', 'i', 't', 'c'}
print("Elementos únicos en 'set2':", set2) # Elementos únicos en 'set2': {'P', ' ', 'j', 'a', 'g', 'n', 'h', 'o', 'y', 't', 'D'}

print("Elementos en set1 pero no en set2", set1 - set2 ) # {'i', 'F', 'z', 'c'}
print("Elementos en set2 pero no en set1", set2 - set1 ) # {'P', ' ', 'j', 'g', 'n', 'h', 'o', 'y', 'D'}

print("Elementos que no repetidos en set1 y set2", set1 | set2 ) #  {'P', 'h', 'o', 'F', 'z', 'i', 'D', 'g', ' ', 'j', 'a', 'n', 'y', 't', 'c'}

print("Elementos en común entre set1 y set2", set1 & set2 ) #  Elementos en común entre set1 y set2 {'t', 'a'}

print("Elementos que no se repitan entre set1 y set2", set1 ^ set2 ) # Elementos que no se repitan entre set1 y set2 {'P', ' ', 'j', 'g', 'n', 'h', 'o', 'F', 'z', 'i', 'y', 'D', 'c'}
```

### Python: Diccionarios

- Creando un diccionario:
```python
dic = {
    "cadena": "esto es una cadena",
	"numero": 2,
	"booleano": False
}
```

- Accediendo a los datos:
```python
dic = {'booleano': False, 'numero': 2, 'cadena': 'esto es una cadena'}
print("dic[\"booleano\"]: ", dic["booleano"]) # False
print("dic[\"cadena\"]: ", dic["cadena"]) # esto es una cadena
print("dic[\"inventado\"]: ", dic["inventado"]) # KeyError: 'inventado'
```

- Actualizar un diccionario:
```python
dic = {'booleano': False, 'numero': 2, 'cadena': 'esto es una cadena'}
dic["booleano"] = True
dic["lista"] = [1,2,3,4,5,True,"cadena"]
print(dic) # {'booleano': True, 'numero': 2, 'cadena': 'esto es una cadena', 'lista': [1, 2, 3, 4, 5, True, 'cadena']}
```

- Borrando en un diccionario
```python
dic = {'booleano': False, 'numero': 2, 'cadena': 'esto es una cadena'}

del dic['booleano']     # Borrar una propiedad
print("dic: ", dic)     # dic:  {'numero': 2, 'cadena': 'esto es una cadena'}

dic.clear()             # Vaciar el diccionario
print("dic: ", dic)     # dic:  {}

del dic                 # Eliminar el diccionario
print("dic: ", dic)     # NameError: name 'dic' is not defined
```

**Propiedades**

- string(dic) *Retorna una cadena con todos los elementos del diccionario*
```python
dic = {'booleano': False, 'numero': 2, 'cadena': 'esto es una cadena'}
print ("Cadena equivalente:", str(dic)) # Cadena equivalente: {'booleano': False, 'numero': 2, 'cadena': 'esto es una cadena'}
```

- len(dic) *Retorna la longitud del diccionario*
```python
dic = {'booleano': False, 'numero': 2, 'cadena': 'esto es una cadena'}
print ("Longitud:", len(dic)) # Longitud: 3
```

**Métodos**

- .copy() *Retorna una copia (shadow copy)*
    - Shadow copy copia los objetos de primer nivel, pero los anidados sólo por referencia    
```python
dic = {'booleano': False, 'numero': 2, 'cadena': 'esto es una cadena'}

dicShadow = dic.copy()
```

- .fromkeys(secuencia [, valor]) *Permite crear un diccionario partiendo de una tupla y valores por defecto*
```python
secuencia = ("dato", "dato2", "otroDato", "mas datos")

dic = dic.fromkeys(secuencia) 
# {'otroDato': None, 'dato': None, 'mas datos': None, 'dato2': None}

otroDic = dic.fromkeys(secuencia, "dato por defecto")
# {'otroDato': 'dato por defecto', 'dato': 'dato por defecto', 'mas datos': 'dato por defecto', 'dato2': 'dato por defecto'}
```

- .get(llave [, retorno_negativo]) *Devuelve el valor de una llave, si no estuviera retorna None o el valor que nosostros definamos*
```python
dic = {'booleano': False, 'numero': 2, 'cadena': 'esto es una cadena'}
print("Cadena:", dic.get("cadena")) # Cadena: esto es una cadena
print("Inventada:", dic.get("Inventada")) # Inventada: None
print("Inventada:", dic.get("Inventada", False)) # Inventada: False
```

- .setdefault(llave [, valor_defecto]) *Ajusta un valor por defecto en caso que no exista*
```python
dic = {'booleano': False, 'numero': 2, 'cadena': 'esto es una cadena'}
dict.setdefault('cadena', "Otra...")
dict.setdefault('otraCadena', False)
print("dic:", dic) # dic: {'booleano': False, 'numero': 2, 'cadena': 'esto es una cadena'}
```

- .items() *Retorna una lista con todos los elementos de un diccionario.*
```python
dic = {'booleano': False, 'numero': 2, 'cadena': 'esto es una cadena'}
dic.items() # dict_items([('booleano', False), ('numero', 2), ('cadena', 'esto es una cadena')])
```

- .keys() *Retorna una lista con todas las llaves de un diccionario.*
```python
dic = {'booleano': False, 'numero': 2, 'cadena': 'esto es una cadena'}
dic.keys() # dict_keys(['booleano', 'numero', 'cadena'])
```

- .values() *Retorna una lista con todos los valores de un diccionario.*
```python
dic = {'booleano': False, 'numero': 2, 'cadena': 'esto es una cadena'}
dic.values() # dict_values([False, 2, 'esto es una cadena'])
```

- .update(dic2) *Añade el contenido de un diccionario en otro*
```python
dic = {'booleano': False}
dic1 = {'numero': 2, 'cadena': 'esto es una cadena'}
dic.update(dic1) # {'booleano': False, 'numero': 2, 'cadena': 'esto es una cadena'}
```

### Python: Funciones
- Nos permiten reutilizar código
- Podemos modelar la entrada de datos en las funciones con argumentos
- Podemos definir la salida de datos de las funcines con los retornos

- **Declaración**
```python
def hola ():
    print("Hola Amigo!")
```

- **Ejecución**
```python
hola("Ulises") #Hola,  Ulises
```

### Python: Funciones: Parámetros

- **Parámetros**
```python
def hola (nombre):
    print("Hola, ", nombre)
```

- **Parámetros opcionales**
    - Por defecto es *None*
```python
def hola(nombre="a todos"):
    """ Saludando... """
    print("Hola " + nombre + "!")

hola("Ulises")
hola()
```

- **Positional arguments - Parámetros variables**
- Al pasarse los datos, la función maneja una tupla.
- Se declaran los argumentos igual que los normales.
- Siempre se situa al final de los parámetros normales y/o opcionales
```python
def funcion(*positional):
    print(positional)

funcion(12, "abc")
# (12, 'abc')
```

- **keyword arguments - Diccionario como parámetro**
- Al pasarse los datos, la función maneja un diccionario.
- Al pasar los argumentos utilizaremos la misma sintaxis que si definieramos parámetros opcionales
- Siempre se situa al final de los parámetros normales, opcionales y keywords
```python
def funcion(**kwargs):
    print(kwargs)

funcion(primerElemento=12, keyword="abc")
# {'keyword': 'abc', 'primerElemento': 12}
```

- **Mezclando todos los parámetros**
```python
def funcion(p1, p2=3, *position, **kwargs):
    print("p1:", p1)
    print("p2:", p2)
    print("Posicionales:", position)
    print("Keywords:", kwargs)

funcion("primero")
# p1: primero
# p2: 3
# Posicionales: ()
# Keywords: {}

funcion("primero", primerElemento=12, keyword="abc")
# p1: primero
# p2: 3
# Posicionales: ()
# Keywords: {'keyword': 'abc', 'primerElemento': 12}

funcion("primero", 2, True, "Más datos...")
# p1: primero
# p2: 2
# Posicionales: (True, 'Más datos...')
# Keywords: {}

funcion("primero", True, primerElemento=12, keyword="abc")
# p1: primero
# p2: True
# Posicionales: ()
# Keywords: {'keyword': 'abc', 'primerElemento': 12}
```


### Python: Funciones: Retorno
- Las funciones por defecto retornan *None*
- Se puede usar el retorno como todos los formatos (tuplas, cadenas, diccionarios, funciones...)
- Retornando un numero
```python
def fahrenheit(temperatura_grados):
    return (temperatura_grados * 9 / 5) + 32

for valor in (22.6, 25.8, 27.3, 29.8):
    print(valor, "°C", "|", fahrenheit(valor), "°F")
```
- Retornando una tupla
```python
def saludar(saludo, nombre):
    return(saludo, nombre)

retorno = saludar("Holaaaa", "Ulises")
print("El retorno es ", type(retorno)) # El retorno es  <class 'tuple'>
```
- Retornando un diccionario
```python
def saludar(saludo, nombre):
    return {"saludo": saludo, "nombre": nombre}

retorno = saludar("Holaaaa", "Ulises")
print("El retorno es ", type(retorno)) # El retorno es  <class 'dict'>
```
- Retornando una función anónima (lambda)
```python
def saludar():
    print("Sorpresa... ahora te cocino una nueva función pero... en el retorno!")
    return lambda saludo, nombre: print(saludo, nombre, "!")
    

retorno = saludar()
print("El retorno es ", type(retorno)) # El retorno es  <class 'function'>
retorno("Holaaaa", "Ulises") # Holaaaa Ulises !
```

### Python: Funciones: Docstring
- Nos permite *documentar* la función
- Se puede acceder desde *nombre_de_la_funcion.__doc__*
- Debe ser la primera línea
- Podemos utilizarlo desde la consola interactiva con *help(nombre_de_la_funcion)* 
```python
def fahrenheit(temperatura_grados):
    """Función que retorna la conversión del parámetro a Fahrenheit"""
    return (temperatura_grados * 9 / 5) + 32

print("El Docstring de la función : " + fahrenheit.__doc__)
```

**Pydocs - Documentación al estilo Python**
- Podemos acceder a la documentación de los módulos desde las terminal
- Tenemos que especificar la version de python y el módulo *pydocs3 nombre_modulo* y *pydocs3.5 nombre_modulo*
```
pydoc3 math
```
- Podemos exportar la documentación en formato HTML
```
pydoc3 -w math
```
- Podemos buscar por una palabra clave en la documentación
```
pydoc3 -k data
```
- Podemos iniciar un servidor web con la documentación, especificando el puerto
```
pydoc3 -p 8080
```
- También podemos iniciar el servidor usando un puerto libre disponible al azar
```
pydoc3 -b
```

### Python: Funciones: Ámbitos
- Por defecto las variables definidas en las funciones son locales y las demas globales
```python
def f(): 
    print(lenguaje)

lenguaje = "Python"
f() 
# Python
```
- Ejemplo de ámbitos
```python
def f(): 
    lenguaje = "Perl"
    print(lenguaje) 


lenguaje = "Python"
f()
print(lenguaje)
# Perl
# Python
```
- Error de ambigüedad
```python
def f(): 
    print(lenguaje) # UnboundLocalError: local variable 'lenguaje' referenced before assignment
    lenguaje = "Perl"
    print(lenguaje)

lenguaje = "Python" 
f()
print(lenguaje)
```
- Definiendo variables globales desde el interior de las funciones
```python
def funcion():
    global animal
    print(animal)
    animal = "perro"
    print(animal)

animal = "gato" 
f()
print(animal)

# gato
# perro
# gato
```


### Python: Funciones: Recursión
Sucesión de Fibonacci
```Python
def Fibonacci(n):
    if n == 0: return 0
    elif n == 1: return 1
    else: return F(n-1)+F(n-2)

print(Fibonacci(10))
```


### Python: Excepciones: Gestión de Errores
- La estructura *try-except* nos permitirá gestionar los errores
- Gestionar las excepciones nos permite evitar que la ejecución del programa se detenga
- Podemos detallar muchos matices a la hora de gestionar los errores con *try*, *except*, *assert*, *TipoError*, *else*, *finally* 

**Lo básico**
- try *Código que probamos*
- except *En caso de error se ejecuta*
```python
while True:
    try:
        n = input("Un número entero: ")
        n = int(n)
        break
    except ValueError:
        print("Eso no era un entero! Intentalo de nuevo...")
```

**Manejando más escenarios**
- except TipoError *En caso de error concreto se ejecuta*
- else *En caso de no contener error se ejecuta*
- finally *En cualquier caso se ejecuta*
```python
try:
    texto = input('Dime algo...')
 
except KeyboardInterrupt: 
    print('Vaya! Presionas... ctrl+c')  # Ctrl+c
 
else: 
    print('Dices...', texto)
  
finally:
    print('En cualquier caso... ciao!')
```

**assert, verificando los detalles**
- Assert nos permite lanzar un error concreto (AssertionError) durante la ejecucción
```python
def funcion(*positional):
    try:
        assert len(positional) > 1
        print(positional)
    except AssertionError:
        print('Debes introduccir al menos 2 argumentos!')

funcion(12) # Debes introduccir al menos 2 argumentos!
funcion(12, "abc") # (12, 'abc')
```

**Manejando errores customizados**
```python
def demo():
    try:
        raise ValueError('Estos son los detalles del error... ')
        raise Exception('Este es el error que necesitas manejar realmente')
    except Exception as error:
        print('El error:', repr(error)) # El error: ValueError('Estos son los detalles del error... ',)

demo() # 
```



### Python: Convertir programas de Python 2.x a 3.x con 2to3
- Muy útil para convertir librerías de terceros
- Basado en el módulo lib2to3
- Nos crea automaticamente una copia de seguridad del original mi_archivo.py.bak
- Sobreescribe el archivo original en Python 2.x a Python 3.x 

**Convetir un archivo (Paso previo)**
```
2to3 archivo.py
```

**Convetir un archivo (Directamente)**
```
2to3 -w archivo.py
```

**Consultando las reglas**
- [Reglas vigentes](https://docs.python.org/3.4/library/2to3.html#to3-fixers)
```
2to3 -l
```

### Python: Evaluar y ejecutar cadenas

- .eval() *Convierte cadenas de texto en estruturas de código válidas*
```python
cadena = '{"saludo": "hola", "nombre": "amigo"}'
print("Tipo:",type(eval(cadena))) # Tipo: <class 'dict'>
```

- .exec() *Convierte cadenas de texto en instrucciones de código*
```python
cadena = 'saludo = "hola amigo"'
exec(cadena)
print(saludo) # hola amigo
```


### Python: Operadores de asignación binária
> Una operación bit a bit o bitwise opera sobre números binarios a nivel de sus bits individuales. 
- [Más info](https://www.wikiwand.com/es/Operador_a_nivel_de_bits)

Tipos de Operación:
- Operaciones bit a bit (lógica)
- Operaciones de Desplazamiento
- Operaciones de Rotación

```python
a = bin(60) #60 -> 0b111100
b = bin(13) #13 -> 0b1101 

#LÓGICA
a&b  #12
a|b  #61
a^b  #49

#ROTACIÓN
~a   #-61
~b   #-14

#DESPLAZAMIENTO
a>>b #0
a<<b #491520
```


### Python: Generadores
- Es una función que genera datos en tiempo de ejecucción
- Es necesario usar *yield*
- *yield* es un retorno qu ese congela y se deconsjela cada vez que llamamos al generador.
- Ejemplos:
- Numeros Pares
```python
def pares():
    indice = 1
    while True:
        yield indice * 2
        indice = indice + 1

for i in pares():
    print("Par actual:", i)
```
- Fibonacci
    - [Más Info](http://stackoverflow.com/questions/494594/how-to-write-the-fibonacci-sequence-in-python) 
```python
def fibonacci():
    a, b = 0, 1
    while True:            
        yield a            
        a, b = b, a + b

for index, fibonacci_number in enumerate(fibonacci()):
     print('{i:3}: {f:3}'.format(i=index, f=fibonacci_number))
     if index == 10:
         break
```

### Python: Iteradores y Generadores
Usando iteradores para Fibonacci
    - [Más Info](http://stackoverflow.com/questions/494594/how-to-write-the-fibonacci-sequence-in-python) 
```python
def Fibonacci():
    a,b = 0,1
    yield a
    yield b
    while True:
        a, b = b, a + b
        yield b
        
def SubFib(startNumber, endNumber):
    for cur in Fibonacci():
        if cur > endNumber: return
        if cur >= startNumber:
            yield cur

for i in SubFib(10, 200):
    print (i)
```

### Python: Memoization
```python
fib_cache = {0:0, 1:1}

def fibonacci(n):
    if n < 0:
        return -1
    if n in fib_cache:
        print ("Secuencia de Fibonacci para %d = %d (cacheado)" % (n, fib_cache[n]))
        return fib_cache[n]
    else:
        fib_cache[n] = fibonacci(n - 1) + fibonacci(n - 2)
    return fib_cache[n]

print (fibonacci(20))
print ("Cache: ", fib_cache)

print (fibonacci(17))
print ("Cache: ", fib_cache)
```



### Python: With
- Es un acortador que nos permite ahorrar multiples lías de código repetitivas
- Su uso es discutido
- Establece el objeto por defecto para un conjunto de sentencias determinado.
```python
with open('archivo.txt', 'w') as archivo:
    archivo.write('Hola, hola!')
```

### Python: Pass
- Placeholder, Tiene un peso nulo pero nos permite delimitar ciertos momentos durante el bucle
- Es muy usado para definir estructuras que posteriormente iremos completando

```python
for letra in 'Fictizia':
    if letra == 'i':
        pass
        print('Pasamos por aquí...')
    print('Letra actual :', letra)
```


### Python: Variables del entorno

VARIABLES del entorno os.envion -> 17 Python Fácil

```
Your code is running at https://curso-python-master-ulisesgascon.c9users.io.
Important: use os.getenv(PORT, 8080) as the port and os.getenv(IP, 0.0.0.0) as the host in your scripts!
```

### Python: Importanto this
```python
>>> import this
The Zen of Python, by Tim Peters

Beautiful is better than ugly.
Explicit is better than implicit.
Simple is better than complex.
Complex is better than complicated.
Flat is better than nested.
Sparse is better than dense.
Readability counts.
Special cases aren't special enough to break the rules.
Although practicality beats purity.
Errors should never pass silently.
Unless explicitly silenced.
In the face of ambiguity, refuse the temptation to guess.
There should be one-- and preferably only one --obvious way to do it.
Although that way may not be obvious at first unless you're Dutch.
Now is better than never.
Although never is often better than *right* now.
If the implementation is hard to explain, it's a bad idea.
If the implementation is easy to explain, it may be a good idea.
Namespaces are one honking great idea -- let's do more of those!
```


### Python: Módulos
- Contienen código en python.
- Solo tenemos que llamarlos para poder acceder a ellos.
- Pueden ser del sistema o de terceros
- Se omite la extensión en la llamada
- Para que un archivo se considere un módulo necesita * __init__.py*
- * __init__.py* puede estar vacío
- **Importando**
```python
import sys
```
- **Usando un módulo**
```python
import sys
print(sys.argv)
```
- **Usando un álias**
```python
import sys as s
print(s.argv)
```

- **Importando una parte solo**
```python
from paquete import *
```

- **Importando todo manteniendo el nombre original**
```python
from sys import argv as argumentos
print(argumentos)
```

### Python: Módulos: Estructuración

- Estructura básica
```
 └── paquete
	  ├── __init__.py
	  ├── modulo1.py
     ├── modulo2.py
     └── modulo3.py
```
- Estructura con sub-paquetes
```
	.
	└── paquete
		├── __init__.py
		├── modulo1.py
		└── subpaquete
			├── __init__.py
			├── modulo1.py
			└── modulo2.py
```
- Y los módulos, no necesariamente, deben pertenecer a un paquete:
```
	.
	├── modulo1.py
	└── paquete
		├── __init__.py
		├── modulo1.py
		└── subpaquete
			├── __init__.py
			├── modulo1.py
			└── modulo2.py
```



### Python: POO

>La programación orientada a objetos (POO, u OOP según sus siglas en inglés) es un paradigma de programación que viene a innovar la forma de obtener resultados. Los objetos manipulan los datos de entrada para la obtención de datos de salida específicos, donde cada objeto ofrece una funcionalidad especial.

>Muchos de los objetos pre-diseñados de los lenguajes de programación actuales permiten la agrupación en bibliotecas o librerías, sin embargo, muchos de estos lenguajes permiten al usuario la creación de sus propias bibliotecas.

>Está basada en varias técnicas, incluyendo herencia, cohesión, abstracción, polimorfismo, acoplamiento y encapsulamiento.

>Su uso se popularizó a principios de la década de 1990. En la actualidad, existe una gran variedad de lenguajes de programación que soportan la orientación a objetos. [POO en wikiwand](https://www.wikiwand.com/es/Programaci%C3%B3n_orientada_a_objetos)

**Resumen**
>La POO es un paradigma surgido en los años 1970, que utiliza objetos como elementos fundamentales en la construcción de la solución. Un objeto es una abstracción de algún hecho o ente del mundo real, con atributos que representan sus características o propiedades, y métodos que emulan su comportamiento o actividad. Todas las propiedades y métodos comunes a los objetos se encapsulan o agrupan en clases. Una clase es una plantilla, un prototipo para crear objetos; en general, se dice que cada objeto es una instancia o ejemplar de una clase.

**Conceptos fundamentales**
- Clase
    - Es el constructor, donde se definen las propiedades y el comportamiento de un objeto
- Herencia
    - Se crea una herencia común entre varias clases, lo que permite reutilizar y modularizar mucho más el código
    - Los componentes pueden ser:
        - Publicos (public) se heredan tal cual   
        - Privados (private) se heredan pero permanecen ocultos, aunque pueden gestionarse con metodos publicos.
        - Protegidos (protected) al igual que los privados, pero estos no se pasarán a las siguientes clases que hereden
- Objeto
    - Es el resultado que producen las clases a traves de las instanciación. Los objetos pueden contener métodos y propiedades. 
- Método
    - Una función como parte de un objeto 
- Propiedad o atributo
    - Características de una clase
    - Son como variables pero dentro de un objeto o clase, pueden alterarse y son visibles
- Estado interno
    - Es una variable privada dentro del objeto o clase


**Características**

- Abstracción
>Denota las características esenciales de un objeto, donde se capturan sus comportamientos. Cada objeto en el sistema sirve como modelo de un "agente" abstracto que puede realizar trabajo, informar y cambiar su estado, y "comunicarse" con otros objetos en el sistema sin revelar "cómo" se implementan estas características. Los procesos, las funciones o los métodos pueden también ser abstraídos, y, cuando lo están, una variedad de técnicas son requeridas para ampliar una abstracción.
>La abstracción es clave en el proceso de análisis y diseño orientado a objetos, ya que mediante ella podemos llegar a armar un conjunto de clases que permitan modelar la realidad o el problema que se quiere atacar.

- Encapsulamiento
>Significa reunir todos los elementos que pueden considerarse pertenecientes a una misma entidad, al mismo nivel de abstracción. Esto permite aumentar la cohesión (diseño estructurado) de los componentes del sistema. 

- Polimorfismo
>Comportamientos diferentes, asociados a objetos distintos, pueden compartir el mismo nombre; al llamarlos por ese nombre se utilizará el comportamiento correspondiente al objeto que se esté usando. O, dicho de otro modo, las referencias y las colecciones de objetos pueden contener objetos de diferentes tipos, y la invocación de un comportamiento en una referencia producirá el comportamiento correcto para el tipo real del objeto referenciado. Cuando esto ocurre en "tiempo de ejecución", esta última característica se llama asignación tardía o asignación dinámica.  

- Herencia
>Las clases no se encuentran aisladas, sino que se relacionan entre sí, formando una jerarquía de clasificación. Los objetos heredan las propiedades y el comportamiento de todas las clases a las que pertenecen.
>Cuando un objeto hereda de más de una clase se dice que hay herencia múltiple; siendo de alta complejidad técnica por lo cual suele recurrirse a la herencia virtual para evitar la duplicación de datos.

- Modularidad
>Se denomina "modularidad" a la propiedad que permite subdividir una aplicación en partes más pequeñas (llamadas módulos), cada una de las cuales debe ser tan independiente como sea posible de la aplicación en sí y de las restantes partes.

- Principio de ocultación
>Cada objeto está aislado del exterior, es un módulo natural, y cada tipo de objeto expone una "interfaz" a otros objetos que especifica cómo pueden interactuar con los objetos de la clase. 
>El aislamiento protege a las propiedades de un objeto contra su modificación por quien no tenga derecho a acceder a ellas; solamente los propios métodos internos del objeto pueden acceder a su estado. 

- Recolección de basura
>La recolección de basura (garbage collection) es la técnica por la cual el entorno de objetos se encarga de destruir automáticamente, y por tanto desvincular la memoria asociada, los objetos que hayan quedado sin ninguna referencia a ellos.

### Python: POO: Clases

**Creando clases**
- Se suele *capitalizar* el nombre de las clases
- Creando una clase vacía
```python
class NombreClase:
    pass
```

**Documentando**
- Se puede utilizar Docstring *NombreClase.__doc__* 
```python
class NombreClase:
    'Esto es lo que luego se ve como Docstring'
    pass
```

**Instanciando una clase**
- Dos objetos instanciados por una misma clase no son iguales.
```python
class MiClase:
    'Esto es lo que luego se ve como Docstring'
    pass

objeto1 = MiClase()
objeto2 = MiClase()
print("Son iguales?", objeto1 == objeto2) # False
```




### Python: POO: Propiedades
- Propiedades públicas
```python
class Coche:
    marca = "Seat"
    modelo = "Ibiza"
    antiguedad = 20
    color = "Azul"
    tipo = "Turismo"

miCoche = Coche()
print("Mi coche es un", miCoche.marca, miCoche.modelo, "de color", miCoche.color)
# Mi coche es un Seat Ibiza de color Azul
```

- Propiedades Privadas
```python
class Coche:
    # Privadas
    numero = 1
    def __init__(self):
        # Públicas
        self.marca = "Audi"
        self.modelo = "S8"
        self.antiguedad = 2
        self.color = "Negro"
        self.tipo = "Berlina"
        self.id = Coche.numero
        
        # Modificando Privadas
        print("ID coche:", Coche.numero)
        Coche.numero += 1

cocheComercial = Coche() # ID coche: 1
cocheJefe = Coche() # ID coche: 2
miCoche = Coche() # ID coche: 3

print("Mi coche ( ID", miCoche.id, ") es un", miCoche.marca, miCoche.modelo, "de color", miCoche.color)
# Mi coche ( ID 3 ) es un Audi S8 de color Negro
```

**Parámetros**

- Pasando parametros opcionales
```python
class Coche:
    # Privadas
    numero = 1
    def __init__(self, marca, modelo, color = "Naranja", antiguedad = 2,  tipo = "Berlina"):
        # Públicas
        self.marca = marca
        self.modelo = modelo
        self.antiguedad = antiguedad
        self.color = color
        self.tipo = tipo
        self.id = Coche.numero
        
        # Modificando Privadas
        print("ID coche:", Coche.numero)
        Coche.numero += 1

miCoche = Coche("Seat", "Panda", "Verde Goblin") # ID coche: 1

print("Mi coche es un", miCoche.marca, miCoche.modelo, "de color", miCoche.color)
# Mi coche es un Seat Panda de color Verde Goblin
```

### Python: POO: Métodos
```python
class Coche:
    marca = "Seat"
    modelo = "Ibiza"
    antiguedad = 20
    color = "Azul"
    tipo = "Turismo"
    
    def detallesTecnicos(self):
        print("Mi coche es un", self.marca, self.modelo, "de color", self.color)

miCoche = Coche()
miCoche.detallesTecnicos()
```

### Python: POO: Funciones útiles
- getattr(objeto, atributo, alternativo) *Accede al atributo y si no lo crea con el valor alternativo*
```python
miCoche = Coche()
colorCoche = getattr(miCoche, "color") # Azul
colorITV = getattr(miCoche, "ITVPasada", True) # True
```

- hasattr(objeto, atributo) *Verifica si el atributo éxiste*
```python
miCoche = Coche()
hasattr(miCoche, "color") # True
hasattr(miCoche, "ITVPasada") # False
```

- setattr(objeto, atributo, valor) *Actualiza el valor y si no existe lo crea con el valor proporcionado*
```python
miCoche = Coche()
setattr(miCoche, "color", "Rojo")
setattr(miCoche, "ITVPasada", False)
```

- delattr(objeto, atributo) *Borra el atributo, si no existe genera un `AttributeError`*
```python
miCoche = Coche()
delattr(miCoche, "color")
delattr(miCoche, "ITVPasada")
```


### Python: POO: Atributos Built-In
```python
print("Todo lo que contiene nuestra clase:", Coche.__dict__)
# Todo lo que contiene nuestra clase: {'detallesTecnicos': <function Coche.detallesTecnicos at 0x7f8b72a4fb70>, 'antiguedad': 20, '__module__': '__main__', 'tipo': 'Turismo', 'color': 'Azul', '__dict__': <attribute '__dict__' of 'Coche' objects>, '__weakref__': <attribute '__weakref__' of 'Coche' objects>, '__doc__': None, 'marca': 'Seat', 'modelo': 'Ibiza'}

print("Nombre de la clase:", Coche.__name__) 
# Nombre de la clase: Coche

print("Documentación:", Coche.__doc__ )
# Documentación: None

print("Módulo donde esta la clase:", Coche.__module__ )
# Módulo donde esta la clase: __main__

print("Tupla de las clases que hereda de:", Coche.__bases__ )
# Tupla de las clases que hereda de: (<class 'object'>,)
```


### Python: POO: Herencia
- Cuando una clase no hereda de ninguna otra, debe hacerse heredar de *object*, que es la clase principal de Python, que define un objeto.
```python
print("Tupla de las clases que heredama:",Coche.__bases__ )
# Tupla de las clases que hereda de: (<class 'object'>,)
```

**Herencia Simple**
```python
class Vehiculo:
    def acelerar(self):
        print("Aceleramos....!")
        
    def frenar (self):
        print("Frenamos....!")
    
    def girar (self):
        print("Giramos....!")
    
    def detalles(self):
        print("Tu coche es un", self.marca, self.modelo, "con", self.antiguedad, "años en servicio")

class Furgon(Vehiculo):
    def __init__(self, taraMinima, cargaUtil, volumenCarga,  marca = "Ford", modelo = "Transit", color = "Amarillo", antiguedad = 2,  tipo = "No definido"):
        self.marca = marca
        self.modelo = modelo
        self.antiguedad = antiguedad
        self.color = color
        self.tipo = tipo
        self.taraMinima = taraMinima
        self.cargaUtil = cargaUtil
        self.volumenCarga = volumenCarga
    
    def detallesTecnicos(self):
        print("Tu coche tiene una Tara mínima de", self.taraMinima, "\nCarga útil de", self.cargaUtil, "y un volumen de carga", self.volumenCarga)


miFurgon = Furgon(1300, 900, "grande")
miFurgon.detallesTecnicos()
# Tu coche tiene una Tara mínima de 1300 
# Carga útil de 900 y un volumen de carga de 5
miFurgon.detalles()
# Tu coche es un Ford Transit con 2 años en servicio
miFurgon.acelerar()
# Aceleramos....!
```

**Herencia Multiple**
```python
class Vehiculo:
    def acelerar(self):
        print("Aceleramos....!")
        
    def frenar (self):
        print("Frenamos....!")
    
    def girar (self):
        print("Giramos....!")
    

class Furgon:
    def cargar (self):
        print("Cargando...!")
    
    def descargar (self):
        print("Descargando...!")
        

class todoterreno:
    def wd2 (self):
        print("2WD activado...!")
    
    def wd4 (self):
        print("4WD activado...!")
        

class Pickup(Vehiculo, Furgon, todoterreno):
    def __init__(self, taraMinima, cargaUtil, volumenCarga,  marca = "Ford", modelo = "Transit", color = "Amarillo", antiguedad = 2,  tipo = "No definido"):
        self.marca = marca
        self.modelo = modelo
        self.antiguedad = antiguedad
        self.color = color
        self.tipo = tipo
        self.taraMinima = taraMinima
        self.cargaUtil = cargaUtil
        self.volumenCarga = volumenCarga
        
    def detallesTecnicos(self):
        print("Tu coche tiene una Tara mínima de", self.taraMinima, "\nCarga útil de", self.cargaUtil, "y un volumen de carga", self.volumenCarga)
    def detalles(self):
        print("Tu coche es un", self.marca, self.modelo, "con", self.antiguedad, "años en servicio")


miPickup = Pickup(1300, 900, "grande")
miPickup.acelerar()
miPickup.cargar()
miPickup.wd4()   
```

**Funciones útiles**

- issubclass(ClaseSuperior, ClaseQueHereda) *Verifica si una clase hereda de otra*
```python
issubclass(Pickup, todoterreno) # True
issubclass(todoterreno, Pickup) # False
```

- isinstance(objeto, clase) *Comprubea si un objeto hereda de uan clase concreta*
```python
miPickup = Pickup(1300, 900, "grande")
isinstance(miPickup, Pickup) # True
isinstance(miPickup, todoterreno) # True
isinstance(miPickup, Coche) # False
isinstance(miPickup, inventado) # NameError: name 'inventado' is not defined
```
